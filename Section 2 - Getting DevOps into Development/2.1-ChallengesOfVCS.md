#The Challenges of Getting Database Code into a VCS

All professional developers recognize the value of using version control. Even in small teams, it seems that most application software developers have learned that using a VCS is prudent and easy. Version control systems have improved their ability to manage a variety of code types as well as team paradigms. The last ten years have seen quite a few open source and free systems, to the point where there is no excuse these days for any software developer not to use version control. Git, in particular, has gained a tremendous following in the last few years, with even TFS providing a git interface for developers. 

However, we have a number of challenges in database development that lead people away from working with Version Control. Let's look at SQL Server in particular and also the varagies of SQL code itself that present difficulties.

One of the challenges many developers have with storing their database code in version control is that they often develop code in a tool such as Management Studio, the code is compiled on the SQL Server instance, and there never is a file that the developer has to save to a VCS.

This is fundamentally different from most other types of development, where a developer works with various text files containing code, saves them, and then compiles or copies them to a server. In relational database development, the code is often never saved as a file, and indeed, the process can be cumbersome getting the code into files.

We also have the issue of each object not easily separated into a separate file. For example, we have tables in databases, which can have indexes, constraints, extended properies, permissions, and more. We can alter a table to include new structures, but the code we would use is completely different, and doesn't even include the old code. Contrast this with the addition of a method to a C# file.

There is a lack of database development tooling, especially for SQL Server databases. Management Studio doesn't easily integrate with version control, and neither do most other editors. Some third party partners have produced tools, and SSDT builds on the Visual Studio capabilities with an offline schema model, but all of these methods require the developer to take actions outside of just writing code, compiling it, clicking save, and then clicking commit. There hasn't been a habit among developers of actually committing code, perhaps because we may write code and compile it, but often developers may tweak the code actually stored in the database and tracking those changes to commit them to version control isn't as easy as it sounds.

Since the database isnâ€™t tightly linked to the code the developer works on, and we often find developers making changes to databases to test code, and then forgetting to save this in a VCS, years of bad habits have resulted in relatively few people understanding how to save their database code.

In addition, the vagaries of the SQL language cause us issues. As I mentioned, I could add permissions or indexes to a table, and don't include the existing code for the table. However, for most of the life of SQL, the language itself differs from other application languages. For example, to make a new object, I use the CREATE statement. To change this, I often use the ALTER statement instead, fundamentally altering language based on timing, not logic. SQL Server 2016 SP1 and Azure help by introducing the CREATE OR ALTER statement, but for most developers using SQL Server (or other relational databases), their code must either take this into account or multiple versions of the code, of which all might not be valid, are needed to recreate the object. This is fundamentally not what we would like to see in a VCS respository.

This strange structure of the T-SQL language means that many techniques we use in team development to reconcile version differences are difficult or impossible to easily use. For example, merges of code are complex, requiring humans to decode and decide which changes to choose from each file. The lack of automatic merging means that team development does not easily scale. A number of developers look to try and link their development database with a VCS and implementing locking to prevent more than one developer from changing an object. Past experience shows this is a places where VCS use becomes cumbersome and thus often ignored.

In the next section, we will look at a few ways that we can store our code, and data, in a VCS.

